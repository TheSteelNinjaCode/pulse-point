import { ComponentManager } from "./component-manager.js";
import { DOMBindingManager } from "./dom-binding-manager.js";
import { EventDelegationManager } from "./event-delegation-manager.js";
import { ExpressionEvaluator, StateManager } from "./pp-reactive-v1.js";
interface LoopBinding {
    template: HTMLTemplateElement;
    expression: string;
    itemVar: string;
    indexVar?: string;
    component: string;
    subscriptionIds: string[];
    renderedItems: LoopItem[];
    keyExpression?: string;
    parentElement: Element;
    placeholder: Comment;
    iterableExpr: string;
    evaluatedIterable?: any[];
    iterableName?: string;
}
interface LoopItem {
    key: string;
    element: Element;
    context: Record<string, any>;
    subscriptionIds: string[];
    textNodeTemplates?: Map<Text, string>;
    attributeTemplates?: Map<Element, Map<string, string>>;
    parentTemplate?: HTMLTemplateElement;
    refTemplates?: Map<Element, string>;
}
export declare class LoopManager {
    eventDelegation?: EventDelegationManager;
    loopBindings: Map<HTMLTemplateElement, LoopBinding>;
    private stateManager;
    private expressionEvaluator;
    private componentManager?;
    private domBindingManager?;
    private cleanupObserver;
    private loopCounter;
    private pendingTemplates;
    private loopItemElements;
    private loopItemContexts;
    private templateRenderer;
    private templateMoveObserver;
    private processingPromises;
    private allLoopsProcessedResolve?;
    private isHydrating;
    private deferredUpdates;
    private processingTemplates;
    private astProcessor;
    constructor(stateManager: StateManager, expressionEvaluator: ExpressionEvaluator);
    setHydrating(hydrating: boolean): void;
    waitForAllLoopsProcessed(): Promise<void>;
    private handleTemplateMoves;
    private updateMovedTemplate;
    getLoopContextForElement(element: Element): Record<string, any> | null;
    setDependencies(componentManager: ComponentManager, domBindingManager: DOMBindingManager): void;
    queueTemplate(template: HTMLTemplateElement, component: string): void;
    processPendingTemplates(): void;
    processTemplate(template: HTMLTemplateElement, component: string): void;
    private parseLoopExpression;
    private setupLoopReactivity;
    renderLoop(binding: LoopBinding, iterableExpr: string): void;
    private refreshLoopItemContent;
    private findComponentElementForScope;
    private findParentLoopContext;
    private findComponentElementForLoop;
    private updateRenderedItems;
    private cleanupNestedLoops;
    private processNestedLoopsInItem;
    private generateItemKey;
    private createItemContextWithParentContext;
    private getAllParentLoopContexts;
    private createItemContext;
    private findAllParentLoopContexts;
    private createLoopItem;
    private preCloneSanitizeTemplate;
    private processRefsInLoopItem;
    private processRefAttribute;
    private executeComponentScriptsInLoopItem;
    private getLoopItemContextForElement;
    private generateInstanceId;
    private getComponentScripts;
    private cleanupRawMustacheAttributes;
    private cleanupElementMustacheAttributes;
    private processElementWithContext;
    private processChildrenRecursively;
    private processChildElementsWithContext;
    private processRefInLoopContext;
    private getComponentForTextNode;
    private processNestedTemplate;
    private findParentLoopContextForNestedTemplate;
    private evaluateComponentPropsWithContext;
    private findComponentElementForTemplate;
    private setupNestedLoopReactivity;
    private getParentLoopContextForElement;
    private extractParentLoopContextFromBinding;
    private renderNestedLoop;
    private extractLoopVariablesOnly;
    private updateNestedRenderedItems;
    private generateNestedItemKey;
    private createNestedLoopItem;
    private updateNestedItemContext;
    private bindLoopItemElement;
    private sortPropsByDependency;
    private setupEventBindingsForLoopItem;
    private processTextNodeWithLoopContext;
    private findActualComponentForTextNode;
    private updateTextNodeWithContext;
    private extractMustacheBindings;
    private createLoopItemBinding;
    private findParentComponentWithPropsFromTemplate;
    private findLoopParentComponent;
    private findOriginalComponentName;
    private updateItemContext;
    private refreshNestedLoops;
    private gatherAllComponentContextsInLoopItem;
    private buildElementSpecificContext;
    private getTextNodeComponent;
    private updateDOMOrder;
    private clearRenderedItems;
    private cleanupLoopItem;
    private performCleanup;
    isLoopItem(element: Element): boolean;
    getLoopItemContext(element: Element): Record<string, any> | undefined;
    private cleanupDetachedTemplates;
    cleanupTemplate(template: HTMLTemplateElement): void;
    getAllLoops(): Map<HTMLTemplateElement, LoopBinding>;
    destroy(): void;
}
export declare class TemplateRenderer {
    private evaluator;
    constructor(evaluator: ExpressionEvaluator);
    static containsMustacheExpression(value: string): boolean;
    render(template: string, context: Record<string, any>, component: string): unknown;
    dependencies(template: string, component: string, state: StateManager): string[];
}
export {};
