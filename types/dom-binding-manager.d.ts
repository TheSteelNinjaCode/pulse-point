import { ComponentManager } from "./component-manager.js";
import { ExpressionEvaluator, StateManager } from "./pp-reactive-v1.js";
import { LoopManager } from "./loop-manager.js";
import { TextNodeManager } from "./text-node-manager.js";
export declare class DOMBindingManager {
    loopManager: LoopManager;
    stateManager: StateManager;
    textNodeManager: TextNodeManager;
    private componentManager;
    private expressionEvaluator;
    private observer;
    private listeners;
    private pendingBindings;
    private pendingTextNodes;
    private applyingUpdates;
    private elementCache;
    private batchedUpdates;
    private processingRAF;
    private updateQueue;
    private eventDelegation;
    private processedElements;
    private templateRenderer;
    private BOOL_REFLECTED;
    private lastValueCache;
    private stringValueCache;
    private refBindings;
    private observerPaused;
    constructor(stateManager: StateManager, componentManager: ComponentManager, expressionEvaluator: ExpressionEvaluator);
    pauseObserver(): void;
    resumeObserver(): void;
    refreshComponentElement(element: Element, component: string): void;
    private refreshComponentTextNodes;
    private walkComponentChildren;
    private createSpreadDirectiveBinding;
    private applyObjectProperties;
    private applySpreadObject;
    private isEventProperty;
    private handleSpreadEventProperty;
    private storeDirectEventListener;
    private clearSpreadAttributes;
    private normalizeAttributeName;
    private storeSpreadSubscription;
    private setupMutationObserver;
    private isRelevantMutation;
    processElement(element: Element, executeBindings?: boolean): void;
    private processElementsBatch;
    private processSingleElement;
    private processLoopTemplates;
    private getDirectComponentTemplates;
    private walkDOM;
    private isTextNodeInsideLoopItem;
    private processElementInContext;
    private createRefBinding;
    private isElementInLoopItem;
    private extractDomMustacheBindings;
    private applyBindings;
    private applyBindingsFromCache;
    private createMustacheBinding;
    private findComponentElementForMustacheBinding;
    private setupEventBindings;
    private scheduleElementUpdate;
    private isCriticalProperty;
    private processBatchedElementUpdates;
    updateElementProperty(element: Element, property: string, value: unknown): void;
    private looksLikeSerializedObject;
    private cachedValueToString;
    private isSameValue;
    private isStyleObject;
    private setBooleanProperty;
    private updateStyleObject;
    private setStringAttribute;
    private setNumericAttribute;
    private setAriaAttribute;
    private setDataAttribute;
    private setGenericAttribute;
    private updateValueCache;
    setBooleanProp(el: Element, attrName: string, value: unknown): boolean;
    processPendingBindings(): void;
    private processTextNodesPending;
    private processMutationsBatch;
    private processTextNodesBatch;
    private rebindChangedElements;
    processElementBindings(element: Element, executeBindings?: boolean): void;
    private cleanupElementsBatch;
    private cleanupElement;
    private cleanupRefBinding;
    private getElementHash;
    private isCacheValid;
    refreshAllBindings(): void;
    destroy(): void;
}
export declare class DOMUtils {
    private static readonly FRAMEWORK_ATTRIBUTES;
    private static domCache;
    private static getDOMCache;
    static shouldIgnoreMustache(element: Element | Text): boolean;
    static isFrameworkAttribute(attrName: string): boolean;
    static isEventAttribute(attrName: string): boolean;
    static shouldBeDirectBinding(element: Element, attrName: string): boolean;
    static isDOMProperty(element: Element, attrName: string): boolean;
    static attributeToPropertyName(attrName: string): string;
    static isBooleanAttribute(attrName: string): boolean;
    static getContextComponent(element: Element): string;
    static getParentOfComponent(componentName: string, elementInComponent: Element): string;
    static findElementForComponent(startElement: Element, targetComponent: string): Element | null;
    static getElementDepth(element: Element): number;
    static getParentComponentForElement(element: Element): string;
    static isTextNodeInsideScript(textNode: Text): boolean;
    static getComponentForNode(node: Node): string;
    static getElementComponent(element: Element): string;
}
